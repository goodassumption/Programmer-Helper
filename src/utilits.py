import sys
import os
import datetime
import importlib.util
from time import sleep

from .errors import *
#from ..main import main

original_stdout = sys.stdout

http_status_descriptions = {
    # 1xx Informational
    100: 'Continue - Продолжить',
    101: 'Switching Protocols - Переключение протоколов',
    102: 'Processing - Обработка',
    103: 'Early Hints - Ранние подсказки',

    # 2xx Success
    200: 'OK - Успешно\nЗапрос обработан успешно.',
    201: 'Created - Создано\nЗапрос выполнен, и создан новый ресурс.',
    202: 'Accepted - Принято\nЗапрос принят, но обработка еще не завершена.',
    203: 'Non-Authoritative Information - Неавторитетная информация\nИнформация, полученная из источника, который не является автором.',
    204: 'No Content - Нет содержимого\nЗапрос успешно обработан, но нет никакого содержимого для отправки.',
    205: 'Reset Content - Сброс содержимого\nЗапрос успешно обработан, и браузер должен сбросить вид документа.',
    206: 'Partial Content - Частичное содержимое\nЗапрос был успешно обработан, но возвращено только частичное содержимое.',
    207: 'Multi-Status - Многостатусный\nСообщение протокола, связанное с выполнением нескольких независимых операций HTTP.',
    208: 'Already Reported - Уже сообщено\nЭлементы коллекции уже были сообщены.',
    226: 'IM Used - Используется IM\nСервер выполнил все запросы из набора запросов, и тело ответа является результатом любого из них.',

    # 3xx Redirection
    300: 'Multiple Choices - Множественный выбор\nНесколько вариантов ответа на запрос.',
    301: 'Moved Permanently - Постоянно перемещено\nРесурс был постоянно перемещен по новому URL.',
    302: 'Found - Найдено\nРесурс временно находится по другому URL.',
    303: 'See Other - См. Другое\nОтвет на запрос находится по другому URL.',
    304: 'Not Modified - Не изменен\nРесурс не был изменен с момента последнего запроса.',
    305: 'Use Proxy - Использовать прокси\nЗапрашиваемый ресурс доступен только через прокси-сервер.',
    307: 'Temporary Redirect - Временное перенаправление\nЗапрос должен быть повторен с другим URL.',
    308: 'Permanent Redirect - Постоянное перенаправление\nЗапрос должен быть повторен с другим URL.',

    # 4xx Client Error
    400: 'Bad Request - Неверный запрос\nСервер не смог обработать запрос из-за ошибки клиента (например, некорректный синтаксис запроса).',
    401: 'Unauthorized - Не авторизован\nТребуется аутентификация для получения запрашиваемого ресурса.',
    402: 'Payment Required - Требуется оплата\nЗарезервировано для будущего использования. Используется для кодов, связанных с платежами.',
    403: 'Forbidden - Запрещено\nСервер отказался авторизовать запрос.',
    404: 'Not Found - Страница не найдена\nПроверьте правильность введённых данных и попробуйте снова.',
    405: 'Method Not Allowed - Метод не разрешен\nМетод запроса не поддерживается для данного ресурса.',
    406: 'Not Acceptable - Неприемлемо\nСервер не может предоставить ответ в формате, который может быть принят клиентом.',
    407: 'Proxy Authentication Required - Требуется аутентификация прокси\nКлиент должен аутентифицироваться на прокси-сервере.',
    408: 'Request Timeout - Истекло время ожидания запроса\nСервер ожидал запрос слишком долго.',
    409: 'Conflict - Конфликт\nЗапрос не может быть выполнен из-за конфликта с текущим состоянием ресурса.',
    410: 'Gone - Удалено\nЗапрошенный ресурс был удален и не будет доступен снова.',
    411: 'Length Required - Требуется длина\nСервер отказывается принимать запрос без определенной длины Content-Length.',
    412: 'Precondition Failed - Предварительное условие не выполнено\nСервер не выполнил одно или несколько условий, установленных в заголовках запроса.',
    413: 'Payload Too Large - Полезная нагрузка слишком велика\nЗапрос слишком велик для обработки сервером.',
    414: 'URI Too Long - URI слишком длинный\nURI, предоставленный в запросе, слишком длинный для обработки сервером.',
    415: 'Unsupported Media Type - Неподдерживаемый тип носителя\nТип данных, отправленных в запросе, не поддерживается сервером.',
    416: 'Range Not Satisfiable - Диапазон не может быть удовлетворен\nЗапрос запрашивает часть ресурса, которая не может быть удовлетворена.',
    417: 'Expectation Failed - Ожидание не выполнено\nСервер не может удовлетворить требования поля заголовка Expect.',
    418: "I'm a teapot - Я чайник\nГотовить кофе в чайнике - плохая идея...",
    421: 'Misdirected Request - Неправильно направленный запрос\nЗапрос был направлен на сервер, который не является целевым сервером.',
    422: 'Unprocessable Entity - Необрабатываемая сущность\nЗапрос был хорошо сформирован, но не может быть обработан.',
    423: 'Locked - Заблокировано\nРесурс, к которому осуществляется доступ, заблокирован.',
    424: 'Failed Dependency - Неудачная зависимость\nЗапрос не может быть выполнен из-за неудачной зависимости.',
    425: 'Too Early - Слишком рано\nСервер отказывается обрабатывать запрос, пока он не будет готов.',
    426: 'Upgrade Required - Требуется обновление\nСервер отказывается выполнять запрос с использованием текущей версии протокола.',
    428: 'Precondition Required - Требуется предварительное условие\nСервер требует, чтобы запрос был условным.',
    429: 'Too Many Requests - Слишком много запросов\nПользователь отправил слишком много запросов за определенный промежуток времени.',
    431: 'Request Header Fields Too Large - Поля заголовка запроса слишком велики\nСервер отказывается обрабатывать запрос, потому что поля заголовка запроса слишком велики.',
    451: 'Unavailable For Legal Reasons - Недоступно по юридическим причинам\nЗапрошенный ресурс заблокирован по юридическим причинам.',

    # 5xx Server Error
    500: 'Internal Server Error - Внутренняя ошибка сервера\nНеожиданная ошибка на стороне сервера.',
    501: 'Not Implemented - Не реализовано\nСервер не поддерживает функциональность, необходимую для выполнения запроса.',
    502: 'Bad Gateway - Ошибка шлюза\nСервер, выступая в роли шлюза или прокси, получил недействительный ответ от вышестоящего сервера.',
    503: 'Service Unavailable - Сервис недоступен\nСервер временно не может обрабатывать запросы.',
    504: 'Gateway Timeout - Истекло время ожидания шлюза\nСервер, выступая в роли шлюза или прокси, не получил своевременный ответ от вышестоящего сервера.',
    505: 'HTTP Version Not Supported - Версия HTTP не поддерживается\nСервер не поддерживает версию HTTP, используемую в запросе.',
    506: 'Variant Also Negotiates - Вариант также согласовывает\nСервер имеет внутреннюю конфигурационную ошибку.',
    507: 'Insufficient Storage - Недостаточно места для хранения\nСервер не может сохранить содержимое, которое должно быть обработано, чтобы завершить выполнение запроса.',
    508: 'Loop Detected - Обнаружен цикл\nСервер обнаружил бесконечный цикл при обработке запроса.',
    510: 'Not Extended - Не расширено\nДальнейшие расширения для запроса не были выполнены сервером.',
    511: 'Network Authentication Required - Требуется сетевая аутентификация\nКлиент должен аутентифицироваться, чтобы получить доступ к сети.'
}

models = {
    'ge-2.5-f': 'gemini-2.5-flash' ,
    'ge-2.5-p': 'gemini-2.5-pro ',
    'll-4': 'llama-4-scout ',
    'ds-r1': 'deepseek-r1',
    'mis-3': 'mistral-small-3',
    'qw-30b': 'qwen-3-30b',
    'qw-235b': 'qwen-3-235b ',
    'gemma-3': 'gemma-3',
}

def make_log(log_text='Am I teapot?'):
    """
### `make_log(log_text='Am I teapot?')`

Добавляет новую запись с временной меткой в лог-файл `logs.txt`.

Функция работает путем полного считывания файла, добавления новой строки к содержимому и последующей полной перезаписи файла.

#### Параметры:
*   `log_text` (str, optional): Текст лог-сообщения для записи в файл. По умолчанию используется `'Am I teapot?'`.

#### Возвращаемое значение:
*   `None`: Функция ничего не возвращает.

#### Побочные эффекты:
*   Читает и полностью перезаписывает файл `logs.txt`.
*   Временно перенаправляет стандартный вывод (`sys.stdout`) в файл для выполнения записи.
*   Зависит от глобальной переменной `original_stdout` для восстановления стандартного вывода после записи.
"""
    pass
    """with open('logs.txt', 'r', encoding='utf-8') as file:
        text = file.read()
    with open('logs.txt', 'w', encoding='utf-8') as file:
        sys.stdout = file
        print(f'{text}{datetime.datetime.now().strftime("%H:%M:%S")} - {log_text}')
        sys.stdout = original_stdout"""

def clear():
    """
### `clear()`

Очищает консоль, используя команду, соответствующую текущей операционной системе (Windows или POSIX-совместимые системы, например, Linux, macOS).

#### Параметры:
*   `None`: Функция не принимает параметров.

#### Возвращаемое значение:
*   `None`: Функция ничего не возвращает.

#### Побочные эффекты:
*   Выполняет системную команду (`cls` для Windows, `clear` для POSIX) для очистки экрана терминала.
*   Записывает в лог сообщение о том, что консоль была очищена.
"""

    make_log('Консоль очищена')
    platform = os.name
    if platform == 'nt':
        os.system('cls')
    elif platform == 'posix':
        os.system('clear')

def get_modules_from_package(package_name):
    """
    Находит все модули и подпакеты внутри заданного пакета.
    Возвращает список полных квалифицированных имен модулей/пакетов.
    """
    src_path = os.path.join(os.getcwd(), "src")

    if src_path not in sys.path:
        sys.path.insert(0, src_path)
    
    modules = set() # Используем set для автоматического удаления дубликатов
    try:
        # Получаем спецификацию пакета
        spec = importlib.util.find_spec(package_name)
        if not spec:
            print(f"Ошибка: Пакет '{package_name}' не найден (spec is None).")
            return []

        # Если это не пакет (т.е. одиночный модуль .py или встроенный модуль)
        if not spec.submodule_search_locations:
            # Проверяем, является ли это файлом .py (одиночный модуль)
            if spec.origin and spec.origin.endswith('.py'):
                modules.add(package_name)
            else:
                # Это может быть встроенный модуль или namespace package без файлов.
                # Мы можем добавить его как одиночный модуль.
                modules.add(package_name)
            return sorted(list(modules))

        # Если это пакет, его расположение (директория) находится в submodule_search_locations
        # Обычно там один путь, но может быть несколько для namespace packages.
        # Для простоты, берем первый путь.
        base_package_path = spec.submodule_search_locations[0]
        
        # Добавляем сам корневой пакет
        modules.add(package_name)

        # Обходим файловую систему, начиная с директории пакета
        for root, dirs, files in os.walk(base_package_path):
            # Игнорируем скрытые директории
            dirs[:] = [d for d in dirs if not d.startswith('.')]

            # Вычисляем относительный путь от корня пакета
            relative_path = os.path.relpath(root, base_package_path)
            
            # Если относительный путь - '.', значит мы в корневой директории пакета
            if relative_path == '.':
                current_package_prefix = package_name
            else:
                # Преобразуем os.sep в '.' для формирования квалифицированного имени
                current_package_prefix = f"{package_name}.{relative_path.replace(os.sep, '.')}"
                
                # Проверяем, является ли директория подпакетом (содержит __init__.py)
                # Это более надежный способ, чем просто проверять наличие __init__.py,
                # потому что find_spec уже подтвердил, что это место поиска подпакетов.
                # Но мы все равно можем добавить проверку __init__.py для явности.
                if '__init__.py' in files:
                    modules.add(current_package_prefix)

            # Ищем модули (.py файлы) в текущей директории
            for filename in files:
                if filename.endswith('.py') and filename != '__init__.py':
                    module_short_name = os.path.splitext(filename)[0]
                    full_module_name = f"{current_package_prefix}.{module_short_name}"
                    modules.add(full_module_name)

    except ImportError:
        print(f"Ошибка: Пакет '{package_name}' не найден.")
        return []
    except Exception as e:
        print(f"Произошла непредвиденная ошибка при поиске модулей: {e}")
        return []
        
    return sorted(list(modules))

def check_status_code(status_code=418):
        if 200 <= status_code < 300: # Всё получилось, всем пофиг (коды успеха) 
            pass
        elif 300 <= status_code < 400: # Коды перенаправления (всем всё ещё пофиг) 
            pass
        elif 400 <= status_code < 500: # Коды ошибок клиента 
            err = ClientSideError(message=f'{status_code} {http_status_descriptions.get(status_code)}')
            exit_mod(err)
        elif 500 <= status_code < 600: # Коды ошибок сервера 
            err = ServerSideError(message=f'{status_code} {http_status_descriptions.get(status_code)}')
            exit_mod(ServerSideError, None, False)

def exit_mod(e = SillyException, funk_to_go = None, isException = True):
    """
    ### `exit_mod(e = SillyException, funk_to_go = None, isException = True)`

    Универсальный обработчик исключений и завершения работы программы. В зависимости от флага `isException`, функция либо обрабатывает ошибку с возможностью перехода к другой функции, либо корректно завершает приложение.

    #### Параметры:
    *   `e` (Exception, optional): Класс или объект исключения для обработки. По умолчанию `SillyException`.
    *   `funk_to_go` (function, optional): Функция, которую нужно вызвать после обработки исключения (например, для возврата в предыдущее меню). Используется, только если `isException` равно `True`. По умолчанию `None`.
    *   `isException` (bool, optional): Флаг, определяющий режим работы. `True` — режим обработки исключения. `False` — режим штатного завершения программы. По умолчанию `True`.

    #### Возвращаемое значение:
    *   Не возвращает значение. Завершает свою работу вызовом другой функции (`funk_to_go`) или полным прекращением выполнения скрипта (`exit(0)`).

    #### Побочные эффекты:
    *   **В режиме исключения (`isException=True`):**
        *   Выводит текст исключения в консоль.
        *   Записывает информацию об исключении в лог-файл с помощью `make_log()`.
        *   Приостанавливает выполнение на 3 секунды.
        *   Если передана `funk_to_go`, вызывает эту функцию для продолжения работы программы.
    *   **В режиме завершения (`isException=False`):**
        *   Выводит прощальное сообщение в консоль.
        *   Записывает в лог информацию о завершении работы.
        *   Приостанавливает выполнение на 3 секунды.
        *   ~~И эпично прыгает с крыши~~ Принудительно завершает выполнение всего скрипта с кодом `0`.
    """

    if isException:
        try:
            raise e
        except Exception as e:
            print(e)
            make_log(e)
            sleep(3)
            if funk_to_go is not None:
                funk_to_go

    else:
        if e is not None:
            try:
                raise e
            except Exception as e:
                print(e)
                make_log(e)
        print('Спасибо, что воспользовались нашим приложением!')
        make_log('Программа завершила работу')
        sleep(3)
        exit(0)
